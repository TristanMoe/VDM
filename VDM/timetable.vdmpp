class timetable is subclass of globals

instance variables
    -- Make train_to_route_map local reference, as route uses pop actions. 
    train_to_route_map: train_route_map;
    public train_to_schedule_map: schedule_map := {|->}; 
    inv train_to_route_map_inv(train_to_route_map); 
    
types 
    -- First station in route must be equal to domain value.
    -- Route and Schedule must be unique for each train. 
    public train_route_map = inmap unique_id to route;
    public schedule_map = inmap unique_id to schedule;
    public next_track_map = map unique_id to set of track;

operations
    public timetable: train_route_map ==> timetable
    timetable(t_r_map) == 
    (
        train_to_route_map := t_r_map; 
        for all t_id in set dom t_r_map do 
        (
            train_to_schedule_map := train_to_schedule_map munion { t_id |-> new schedule(t_id, t_r_map(t_id)) };
        );
    ); 

    copy_train_to_route_map: train_route_map ==> train_route_map
    copy_train_to_route_map(t_r_m) == 
    (
        return {t_id |-> t_r_m(t_id) | t_id in set dom t_r_m }; 
    );

    -- Input is all the trains' routes. 
    -- Output is a schedule for each train that fulfills requirements. 
    -- Schedule are made of cycles, where a train can ADVANCE OR WAIT. 
    -- It must create cycles that avoid collisions and ensure trains reach their destination.
    -- Collisions occurs if two trains try to occupy the same track in a cycle. 
    public generate_schedules: () ==> schedule_map
    generate_schedules() == 
    (
        dcl temp_train_to_route_map : train_route_map := copy_train_to_route_map(train_to_route_map); 
        while exists sch in set rng train_to_schedule_map & not sch.destination_part_of_schedule()
        do 
        (
            dcl n_t_map: next_track_map := get_next_track_map(train_to_route_map);
            -- Used to make all tracks vacant after each loop. 
            dcl occupancy_map: inmap unique_id to track := {|->};  

            for all t_id in set dom train_to_route_map 
            do 
            (   
                -- Find track that advances to next station in route. 
                -- Station can have several tracks connected to same station.
                -- Find first available and occupy.  
                -- If no available tracks, wait for next iteration. 
                if exists tr in set n_t_map(t_id) & not tr.is_occupied
                then 
                    (
                        def available_tracks: set of track = { tr | tr in set n_t_map(t_id) & not tr.is_occupied }
                            in 
                            (
                                train_to_route_map(t_id).continue_route(); 

                                -- Take 'random' available track and occupy it. 
                                let tr in set available_tracks 
                                    in 
                                    (
                                        tr.occupy_track(t_id); 
                                        occupancy_map := occupancy_map munion {t_id |-> tr}; 
                                        -- Add advance action, advance in route map and occupy track
                                        train_to_schedule_map(t_id).push_action(mk_(<ADVANCE>, tr));
                                        train_to_schedule_map(t_id).push_action(mk_(<RELEASE>, tr));
                                    );

                                if train_to_route_map(t_id).get_next() = nil
                                then (
                                    train_to_schedule_map(t_id).push_action(mk_(<FINAL>, nil));
                                    -- Remove train from train_route_map 
                                    train_to_route_map := {t_id} <-: train_to_route_map
                                );
                            ); 
                    )
                else 
                (
                    -- Wait for advance and release. 
                    train_to_schedule_map(t_id).push_action(mk_(<WAIT>, nil));
                    train_to_schedule_map(t_id).push_action(mk_(<WAIT>, nil));
                );
            ); 

            -- Make all tracks vacant again. 
            for all t_id in set dom occupancy_map do
                occupancy_map(t_id).vacant_track(t_id); 
        );         

        -- Reset routes. 
        for all t_id in set dom temp_train_to_route_map do
            temp_train_to_route_map(t_id).reset_route(); 

        return train_to_schedule_map; 
    ); 

    pure get_next_track_map: train_route_map ==> next_track_map 
    get_next_track_map(t_r_map) == 
    (
        return { t_id |-> {tr | tr in set t_r_map(t_id).get_next().get_tracks() 
            & tr.includes_station(t_r_map(t_id).get_current().get_id()) }
        | t_id in set dom t_r_map}
    );

    -- Train id should match first station id in route. 
    pure train_to_route_map_inv: train_route_map ==> bool 
    train_to_route_map_inv(t_r_m) == 
    (
        return forall t_id in set dom t_r_m & t_r_m(t_id).get_stations()(1).get_id() = t_id;
    ); 

functions
    set_2_seq_tracks: set of track -> seq of track 
    set_2_seq_tracks(trs) == 
    (
        if trs = {}
        then []
        else let tr in set trs 
            in 
                [tr] ^ set_2_seq_tracks(trs \ {tr})
    )
    measure card trs;

end timetable