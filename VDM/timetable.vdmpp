class timetable is subclass of globals

instance variables
    -- Make train_to_route_map local reference, as route uses pop actions. 
    train_to_route_map: train_route_map;
    public train_to_schedule_map: schedule_map := {|->}; 
    inv train_to_route_map_inv(train_to_route_map); 
    
types 
    -- First station in route must be equal to domain value.
    -- Route and Schedule must be unique for each train. 
    public train_route_map = inmap unique_id to route;
    public schedule_map = inmap unique_id to schedule;
    public next_track_map = map unique_id to set of track;

operations
    public timetable: train_route_map ==> timetable
    timetable(t_r_map) == 
    (
        train_to_route_map := t_r_map; 
        for all t_id in set dom t_r_map do 
        (
            train_to_schedule_map := train_to_schedule_map munion { t_id |-> new schedule(t_id, t_r_map(t_id)) };
        );
    ); 

    copy_train_to_route_map: train_route_map ==> train_route_map
    copy_train_to_route_map(t_r_m) == 
    (
        return {t_id |-> t_r_m(t_id) | t_id in set dom t_r_m }; 
    );

    -- Input is all the trains' routes. 
    -- Output is a schedule for each train that fulfills requirements. 
    -- Schedule are made of cycles, where a train can ADVANCE OR WAIT. 
    -- It must create cycles that avoid collisions and ensure trains reach their destination.
    -- Collisions occurs if two trains try to occupy the same track in a cycle. 
    public generate_schedules: () ==> schedule_map
    generate_schedules() == 
    (
        dcl temp_train_to_route_map : train_route_map := copy_train_to_route_map(train_to_route_map); 
        while exists sch in set rng train_to_schedule_map & not sch.destination_part_of_schedule()
        do 
        (
            dcl n_t_map: next_track_map := get_next_track_map(train_to_route_map);
            -- Used to make all tracks vacant after each loop. 
            dcl occupancy_map: inmap unique_id to track := {|->};  

            for all t_id in set dom train_to_route_map 
            do 
            (   
                -- Find track that advances to next station in route. 
                -- Station can have several tracks connected to same station.
                -- Find first available and occupy.  
                -- If no available tracks, wait for next iteration. 
                if exists tr in set n_t_map(t_id) & not tr.is_occupied
                then 
                    (
                        def available_tracks: set of track = { tr | tr in set n_t_map(t_id) & not tr.is_occupied }
                            in 
                            (
                                train_to_route_map(t_id).continue_route(); 

                                -- Take 'random' available track and occupy it. 
                                let tr in set available_tracks 
                                    in 
                                    (
                                        tr.occupy_track(t_id); 
                                        occupancy_map := occupancy_map munion {t_id |-> tr}; 
                                        -- Add advance action, advance in route map and occupy track
                                        train_to_schedule_map(t_id).push_action(mk_(<ADVANCE>, tr));
                                        train_to_schedule_map(t_id).push_action(mk_(<RELEASE>, tr));
                                    );

                                if train_to_route_map(t_id).get_next() = nil
                                then (
                                    train_to_schedule_map(t_id).push_action(mk_(<FINAL>, nil));
                                    -- Remove train from train_route_map 
                                    train_to_route_map := {t_id} <-: train_to_route_map
                                );
                            ); 
                    )
                else 
                (
                    -- Wait for advance and release. 
                    train_to_schedule_map(t_id).push_action(mk_(<WAIT>, nil));
                    train_to_schedule_map(t_id).push_action(mk_(<WAIT>, nil));
                );
            ); 

            -- Make all tracks vacant again. 
            for all t_id in set dom occupancy_map do
                occupancy_map(t_id).vacant_track(t_id); 
        );         

        -- Reset routes. 
        for all t_id in set dom temp_train_to_route_map do
            temp_train_to_route_map(t_id).reset_route(); 

        return train_to_schedule_map; 
    )
    post generate_schedules_inv(get_seq_schedule_actions(RESULT)); 

    pure get_next_track_map: train_route_map ==> next_track_map 
    get_next_track_map(t_r_map) == 
    (
        return { t_id |-> {tr | tr in set t_r_map(t_id).get_next().get_tracks() 
            & tr.includes_station(t_r_map(t_id).get_current().get_id()) }
        | t_id in set dom t_r_map}
    );

    -- Train id should match first station id in route. 
    pure train_to_route_map_inv: train_route_map ==> bool 
    train_to_route_map_inv(t_r_m) == 
    (
        return forall t_id in set dom t_r_m & t_r_m(t_id).get_stations()(1).get_id() = t_id;
    ); 

    pure get_seq_schedule_actions: schedule_map ==> map unique_id to seq of schedule`action_track 
    get_seq_schedule_actions(s_m) == 
    (
        return { t_id |-> s_m(t_id).get_actions() | t_id in set dom s_m };
    );

functions 
    -- Must of the schedule criteria is handled by the schedule class.
    -- However the timetable must ensure that no inconsistencies occur between
    -- the generated schedules. 
    public generate_schedules_inv: map unique_id to seq of schedule`action_track -> bool 
    generate_schedules_inv(s_a) == 
        forall t_id1, t_id2 in set dom s_a & t_id1 <> t_id2 => (forall b in seq check_schedule_sequence(s_a(t_id1), s_a(t_id2)) & b = true); 

    check_schedule_sequence: seq of schedule`action_track * seq of schedule`action_track -> seq of bool 
    check_schedule_sequence(s1, s2) == 
        -- Sequences can have varying lengths depending on destination etc. 
        if s1 = [] or s2 = [] or (hd s1).#1 <> <ADVANCE> or (hd s2).#1 <> <ADVANCE> 
        then [true]
        else [check_advance_action(hd s1, hd s2)] ^ check_schedule_sequence(tl s1, tl s2)
    -- Recursion shoud stop based on the shortest sequence. 
    measure if len s1 < len s2 then len s1 else len s2; 

    -- If the advance, they must not hold reference to same track. 
    check_advance_action: schedule`action_track * schedule`action_track -> bool 
    check_advance_action(a1, a2) == 
        a1.#2 <> a2.#2 
    pre a1.#1 = <ADVANCE> and a1.#1 = <ADVANCE>;

end timetable