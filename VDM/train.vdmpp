class train is subclass of globals, BaseThread

instance variables 
    id : unique_id; 
    train_route_schedule : [route_schedule] := nil;
    occupied_track : [track] := nil; 
    is_finished : bool := false; 

types 
    public route_schedule ::
            route : route
            schedule : schedule;

    public train_route_schedule_map = inmap unique_id to route_schedule

operations 
    public train: unique_id * [ThreadDef] ==> train 
    train(i_d, t_def) == 
    (
        id := i_d; 
        if t_def <> nil
        then (period := t_def.p;
            isPeriodic := t_def.isP;
       );
        BaseThread(self);        
    );

    public set_schedule_and_route: schedule * route ==> ()
    set_schedule_and_route(s, r) == 
    (
        train_route_schedule := mk_route_schedule(r, s);    
    )
    pre schedule_inv(s) and schedule_route_inv(s, r);

    pure public get_id: () ==> unique_id 
    get_id() == 
        return id; 

    pure public get_route_schedule_map: () ==> train_route_schedule_map 
    get_route_schedule_map() ==
        return {id |-> train_route_schedule}
    pre train_route_schedule <> nil; 

    -- TODO: For some reason it will not take tuple. 
    advance: schedule`action * track ==> () 
    advance(act, tr) == 
    (
        dcl current_station : station := train_route_schedule.route.get_current(); 
        dcl next_station : [station] := train_route_schedule.route.get_next();
        tr.occupy_track(id); 
        occupied_track := tr; 

        train_route_schedule.route.continue_route();        

        print_advance(current_station, next_station); 
    )
    pre train_route_schedule <> nil and act = <ADVANCE> 
        and len train_route_schedule.route.get_stations() > 2;

    wait: schedule`action ==> ()
    wait(act) == 
    (
        dcl current_station : station := train_route_schedule.route.get_current();

        print_wait(current_station); 
    )
    pre train_route_schedule <> nil and act = <WAIT>;

    final: schedule`action ==> () 
    final(act) == 
    (
        dcl current_station : station := train_route_schedule.route.get_current();
        print_final(current_station); 

        -- Unregister thread.
        --TimeStamp`GetInstance().UnRegisterThread(registeredSelf); 
        is_finished := true; 
    )
    pre train_route_schedule <> nil 
        and act = <FINAL> 
        and len train_route_schedule.schedule.get_actions() = 0;

    release: schedule`action ==> ()
    release(act) == 
    (
        -- Use cycle to 'deoccupy' track 
        IO`println("Releasing track...");
        occupied_track.vacant_track(id); 
        occupied_track := nil; 
    )
    pre occupied_track <> nil and act = <RELEASE>; 

    pure schedule_inv: schedule ==> bool 
    schedule_inv(s) ==
        return s.get_owner_id() = id; 

    pure schedule_route_inv: schedule * route ==> bool 
    schedule_route_inv(s, r) ==
        return len [a | a in seq s.get_actions() & a.#1 = <ADVANCE>] <= len r.get_stations();

    -- Step through the schedule actions
    public Step : () ==> ()
    Step() ==
    (
        dcl act_tr : schedule`action_track := train_route_schedule.schedule.pop_action(); 

        cases act_tr.#1 :
        <ADVANCE> -> advance(act_tr.#1, act_tr.#2),
        <RELEASE> -> release(act_tr.#1),
        <WAIT> -> wait(act_tr.#1),
        <FINAL> -> final(act_tr.#1)
        end;
    )
    pre len train_route_schedule.schedule.get_actions() > 0 and not is_finished; 

    public isDone: () ==> bool 
    isDone() == return isFinished(); 

    public isFinished : () ==> bool
    isFinished () == return is_finished; 

    print_advance: station * [station] ==> () 
    print_advance(c_s, n_s) == 
    (
        IO`print("Train "); 
        IO`print(id);
        IO`print(" Advancing from station ");
        IO`print(c_s.get_id());

        if n_s <> nil 
        then 
        (
        IO`print(" to station ");
        IO`println(n_s.get_id()); 
        )
        else 
        (
            IO`println(""); 
        );
    );

    print_wait: station ==> () 
    print_wait(s) == 
    (
        IO`print("Train "); 
        IO`print(id);
        IO`print(" Waiting at station: ");
        IO`println(s.get_id()); 
    );

    print_final: station ==> () 
    print_final(s) == 
    ( 
        IO`print("Train "); 
        IO`print(id);
        IO`print(" Arrived at final destination: ");
        IO`println(s.get_id()); 
    ); 

sync 
    mutex (Step); 
    mutex (isFinished); 
    -- Step until all actions have been executed. 
    -- Cannot have underscore using per keyword. 
    --per isFinished => len train_route_schedule.schedule.get_actions() = 0; 

end train 