class station 

instance variables
    public id: station_id; 
    -- IMPORTANT THAT TRACKS ARE BY REFERENCE! Â¨
    -- This also means one could add additional tracks to same station. 
    public connected_tracks: set of track;
    inv station_inv(id, connected_tracks); 

types 
    public station_id = nat; 

operations
    public station: station_id * set of track ==> station 
    station(i_d, c_t) == 
    (
        atomic (
            id := i_d; 
            connected_tracks := c_t; 
        )
    )
    pre station_inv(i_d, c_t); 

    pure public get_tracks: () ==> set of track 
    get_tracks() == 
        return connected_tracks;  

    pure public get_id: () ==> station_id
    get_id() == 
        return id; 

    pure public get_tracks_to_station: station_id ==> set of track 
    get_tracks_to_station(i_d) == 
    (
        return {tr | tr in set connected_tracks & tr.includes_station(i_d)}
    )
    pre exists tr in set connected_tracks & tr.includes_station(id); 

    pure public get_connected_stations: () ==> set of station_id 
    get_connected_stations() == 
    (
        return find_stations(id, get_tracks());
    ); 

    public print: () ==> () 
    print() == 
    (
        (IO`print("Station: ");
         IO`print(id);
        ); 

        IO`println(""); 

        for all tr in set connected_tracks do
            tr.print(); 
    );

    
    pure find_stations: station_id * set of track ==> set of station_id  
    find_stations(i_d, trs) == 
    (
        if trs = {}
        then return {}
        else let tr in set trs
            in
                return { stat_id | stat_id in set tr.get_connected_stations() & stat_id <> i_d } 
                    union find_stations(i_d, trs \ {tr})

    );

functions
    -- Ensure that all tracks are connected to station.
    station_inv: station_id * set of track -> bool
    station_inv(i_d, c_t) ==
        forall tr in set c_t & i_d in set tr.get_connected_stations(); 

end station 